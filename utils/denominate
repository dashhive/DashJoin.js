#!/usr/bin/env node
//# vi: ft=js

const usage = [
  "Usage: denominate [--custom-source=N] [--dry-run]",
  "",
  "flags: ",
  "   --use-script=FILE   specify your own scripts file. Should be a json file.",
  "   --dump-scripts      if specified, will dump the scripts variable then exit.",
  "                       If used with --use-script=FILE, will dump the scripts after ",
  "                       FILE has been imported by --use-script",
  "   --only-source       when combined with --custom-source=FOO, will only transfer ",
  "                       funds from the wallet named FOO and will use all other wallets ",
  "                       as destination wallets. Handy if you have one wallet with tons of ",
  "                       coins and a bunch of other wallets with hardly anything.",
  "   --custom-source=N   use a specific source wallet to pay all other wallets",
  "   --inspect           if set, will show debug info",
  "   --dry-run           if set, wont actually run commands that spend DASH",
  "   --help|-h           this help screen",
  "",
  "example: denominate --custom-source=han",
  "example: denominate",
  "",
  "denominate will loop through scripts in the ~/bin directory ",
  "and attempt to send denominations to each address it finds in the ",
  "listaddressgroupings sub-cmd of dash-cli. The default mode is to ",
  "do the above, or you can have one wallet sending to all other wallets ",
  "by using --custom-source=N where N is the user. The user must exist ",
  "in the scripts array.",
  "",
  "The scripts array is hard-coded, but if you need to, you can extend this",
  "script to read from a json file or something.",
  "",
  "The scripts array can be dumped by passing in --dump-scripts",
].join("\n");
const fs = require("fs/promises");
if (process.argv.includes("--help") || process.argv.includes("h")) {
  console.info(usage);
  process.exit(1);
}
const proc = require("child_process");
const HOME_DIR = process.env.HOME;
const DENOM_AMOUNT = 1.00001;
function denomination_count() {
  return DENOM_AMOUNT;
}
let source = "luke";
for (let arg of process.argv) {
  let matches = arg.match(/^\-\-custom\-source=(.*)$/);
  if (matches) {
    source = matches[1];
    console.info(`[+] Using "${source}" as source wallet.`);
    break;
  }
}
let scripts = [
  {
    path: "~/bin/dl",
    wallet: "luke",
  },
  {
    path: "~/bin/dh",
    wallet: "han",
  },
  {
    path: "~/bin/dche",
    wallet: "chewie",
  },
  {
    path: "~/bin/dp",
    wallet: "psend",
  },
  {
    path: "~/bin/df",
    wallet: "foobar",
  },
];
for (const arg of process.argv) {
  let matches = arg.match(/^\-\-use\-script=(.*)$/);
  if (matches) {
    scripts = require(matches[1]);
    console.info(`[+] Using scripts file: '${matches[1]}'`);
  }
}
if (process.argv.includes("--dump-scripts")) {
  console.log(scripts);
  process.exit();
}
function inspectScripts() {
  for (const s of scripts) {
    console.info("[path]:", s.path);
    console.info("[wallet]:", s.wallet);
    for (const g of s.groupings) {
      console.info(g);
    }
  }
}
async function processScript(script, address) {
  for (const s of scripts) {
    if (s.wallet === script.wallet) {
      continue;
    }
    if (process.argv.includes("--dry-run")) {
      console.log(
        "mocking:",
        s.path,
        "sendtoaddress",
        address[0],
        denomination_count()
      );
      continue;
    }
    let ps = await proc.spawnSync(s.path, [
      "sendtoaddress",
      address[0],
      denomination_count(),
    ]);
    if (typeof ps.stdout.toString !== "undefined") {
      console.log(ps.stdout.toString().replace(/[\n]+$/, ""));
    }
    if (typeof ps.stderr.toString !== "undefined") {
      if (ps.stderr.toString().length) {
        console.error(ps.stderr.toString());
      }
    }
  }
}
function luke() {
  for (let i = 0; i < scripts.length; i++) {
    if (scripts[i].wallet === source) {
      return scripts[i];
    }
  }
}
async function processScripts() {
  let src = luke();
  if (process.argv.includes("--only-source")) {
    for (const s of scripts) {
      if (s.wallet === source) {
        continue;
      }
      for (const g of s.groupings[0]) {
        if (process.argv.includes("--dry-run")) {
          console.log(
            "mocking:",
            src.path,
            "sendtoaddress",
            g[0],
            denomination_count()
          );
          continue;
        }
        let ps = await proc.spawnSync(src.path, [
          "sendtoaddress",
          g[0],
          denomination_count(),
        ]);
        if (typeof ps.stdout.toString !== "undefined") {
          console.log(ps.stdout.toString().replace(/[\n]+$/, ""));
        }
        if (typeof ps.stderr.toString !== "undefined") {
          if (ps.stderr.toString().length) {
            console.error(ps.stderr.toString());
          }
        }
      }
    }
    process.exit();
    return;
  }
  for (const s of scripts) {
    if (s.groupings.length === 1) {
      await processScript(s, s.groupings[0][0]);
      continue;
    }
    for (const g of s.groupings[0]) {
      await processScript(s, g);
    }
  }
}
(async function () {
  for (let i = 0; i < scripts.length; i++) {
    scripts[i].path = scripts[i].path.replace(/^~/, HOME_DIR);
  }

  for (let i = 0; i < scripts.length; i++) {
    let ps = await proc.spawnSync(scripts[i].path, ["listaddressgroupings"]);
    scripts[i].groupings = JSON.parse(ps.stdout.toString());
  }
  if (process.argv.includes("--inspect")) {
    inspectScripts();
  }
  await processScripts();
  if (process.argv.includes("--inspect")) {
    inspectScripts();
  }
})();
